from typing import Any, Tuple
import numpy as np
import xarray as xr
import json
from pathlib import Path
from empty_bmi import EmptyBmi

class LeakyBucketBmi(EmptyBmi):
    """Demonstration of a minimal hydrological model.

    🌧️
    🪣
    💧
    """

    def initialize(self, config_file: str) -> None:
        # The model config contains the precipitation file, and the model parameter.
        f = open(config_file)
        self.config: dict[str, Any] = json.load(f)
        f.close()

        # Get the input data:
        #   Note: the precipitation input is in [kg m-2 s-1]
        self.precipitation = load_var(self.config["precipitation_file"],"pr")
        self.time_data = self.precipitation["time"]

        # time step size in seconds (to be able to do unit conversions).
        self.timestep_size = (
            self.time_data.values[1] - self.time_data.values[0]
        ) / np.timedelta64(1, "s")

        self.current_timestep = 0
        self.end_timestep = self.time_data.size

        # Define the model states:
        self.storage = 0.0  # [kg m-2 == m-1 (water depth equivalent)]
        self.discharge = 0.0  # [m d-1]

        # The one model parameter is the 'leakiness' of the buckets:
        #   the leakiness value is in [d-1].
        self.leakiness = self.config["leakiness"]

    def update(self) -> None:
        if self.current_timestep < self.end_timestep:
            # Add the current timestep's precipitation to the storage
            self.storage += (
                self.precipitation.isel(time=self.current_timestep).to_numpy()
                * self.timestep_size
            )

            # Calculate the discharge [m d-1] based on the leakiness and storage
            self.discharge = self.storage * self.leakiness
            # Subtract this discharge from the storage
            #   The discharge in [m d-1] has to be converted to [m] per timestep.
            self.storage -= self.discharge * (self.timestep_size / 24 / 3600)

            # Advance the model time by one step
            self.current_timestep += 1

    def get_component_name(self) -> str:
        return "leakybucket"

    def get_value(self, var_name: str, dest: np.ndarray) -> np.ndarray:
        if(var_name == "storage"):
            dest[:] = np.array(self.storage)
            return dest
        elif(var_name == "discharge"):
            dest[:] = np.array(self.discharge / (self.timestep_size / 24 / 3600))
            return dest
        else:
            raise ValueError(f"Unknown variable {var_name}")

    def get_var_units(self, var_name: str) -> str:
        if(var_name == "storage"):
            return "m"
        elif(var_name == "discharge"):
            return "m d-1"
        else:
            raise ValueError(f"Unknown variable {var_name}")

    def set_value(self, var_name: str, src: np.ndarray) -> None:
        if(var_name == "storage"):
            self.storage = src[0]
        elif(var_name == "leakiness"):
            self.leakiness = src[0]
        else:
            raise ValueError(f"Cannot set value of var {var_name}")

    def get_output_var_names(self) -> Tuple[str]:
        return ("discharge","leakiness")

    # The BMI has to have some time-related functionality:
    def get_start_time(self) -> float:
        """Return end time in seconds since 1 january 1970."""
        return get_unixtime(self.time_data.isel(time=0).values) # type: ignore

    def get_end_time(self) -> float:
        """Return end time in seconds since 1 january 1970."""
        return get_unixtime(self.time_data.isel(time=-1).values) # type: ignore

    def get_current_time(self) -> float:
        """Return current time in seconds since 1 january 1970."""
        return get_unixtime(
            self.time_data.isel(time=self.current_timestep).values # type: ignore
        )

def load_var(ncfile: str | Path, varname: str ) -> xr.DataArray:
    """Load the precipitation data file generated by GenericLumpedForcing.


    .. code-block:: python

        from ewatercycle.base.forcing import GenericLumpedForcing

        shape = Path("./src/ewatercycle/testing/data/Rhine/Rhine.shp")
        cmip_dataset = {
            "dataset": "EC-Earth3",
            "project": "CMIP6",
            "grid": "gr",
            "exp": ["historical",],
            "ensemble": "r6i1p1f1",
        }

        forcing = GenericLumpedForcing.generate(
            dataset=cmip_dataset,
            start_time="2000-01-01T00:00:00Z",
            end_time="2001-01-01T00:00:00Z",
            shape=shape.absolute(),
        )

        data = load_precip(forcing.directory / forcing.pr)
    """
    data = xr.open_dataset(ncfile)
    assert "time" in data.dims
    assert varname in data.data_vars
    return data[varname]

def get_unixtime(dt64: np.datetime64) -> float:
    """Get unix timestamp (seconds since 1 january 1970) from a np.datetime64."""
    return dt64.astype("datetime64[s]").astype("int")